# Cloudflare Installation Design (VM)

## Summary
- **Goal:** Define a deterministic, minimal-host installation of Cloudflare Tunnel for the VM.
- **Note:** SSH setup is deferred because the VM is local-only; Cloudflare Tunnel provides public access needed before GitHub Actions runner can SSH.

## Front Matter
- **Title:** Cloudflare Installation Design (VM)
- **Project:** n8n self-hosting app
- **Owner:** Malik
- **Status:** Draft
- **Last updated:** 2026-01-25
- **Related docs:** `Design/1. package handling design.md`

## Global Variables (select here)
| **Variable** | **Value** |
| --- | --- |
| **`SUPPORTED_OS`** | Ubuntu 22.04 LTS or Debian 12 |
| **`PRIMARY_OS`** | Ubuntu 22.04 LTS |
| **`CLOUDFLARE_PRODUCT`** | cloudflared (Cloudflare Tunnel) |
| **`CLOUDFLARE_INSTALL_MODE`** | Docker container |
| **`CLOUDFLARE_IMAGE`** | cloudflare/cloudflared |
| **`CLOUDFLARE_IMAGE_TAG`** | Pinned in `ops/dependencies.md` (source of truth) |
| **`CLOUDFLARE_CONFIG_PATH`** | `ops/cloudflared/config.yml` |
| **`CLOUDFLARE_TOKEN_SOURCE`** | Manual operator input on VM (phase 1), CI secret store (phase 2) |
| **`CONFIG_TRANSFER_METHOD`** | Manual copy from repo to VM with checksum verification |

## Decisions
| **Decision** | **Rationale** | **Alternatives** | **Impact** |
| --- | --- | --- | --- |
| Run cloudflared as a Docker container. | Aligns with host minimalism and package separation. | Install cloudflared on the host via apt. | No host packages added; cloudflared lifecycle via Docker Compose. |
| Use token-based tunnel authentication. | Simplest, non-interactive deployment. | Certificate-based auth. | Requires secure CI secret management. |
| Store config in repo and inject token at runtime. | Keeps config auditable and avoids secrets on disk. | Store config and secrets on VM. | Token is provided manually in phase 1 and via CI in phase 2. |

## Definitions (optional)
- **cloudflared:** Cloudflare Tunnel client that proxies traffic to the VM.
- **Tunnel token:** One-time generated secret for authenticating cloudflared to Cloudflare.

## Overview
- **Goal:** Install and run Cloudflare Tunnel without adding host-level runtime packages.
- **Target users:** Single-VM admin/operator.
- **Business value:** Secure, deterministic ingress with minimal host drift.
- **Execution model:** Manual setup on the VM to establish public access before CI-based SSH.

## Scope
- **In scope:** Containerized cloudflared install; config management; secret injection; service lifecycle in Docker Compose.
- **Out of scope:** DNS and zone setup in Cloudflare UI; WAF rules; enterprise Cloudflare products.
- **Assumptions:** Docker is installed via the package handling design; phase 1 is manual on the VM; phase 2 uses CI after public access exists.
- **Constraints:** No host-installed cloudflared packages; pinned image tags only.

## Requirements
| **Type**           | **Requirement**                                                |
| ------------------ | -------------------------------------------------------------- |
| **Functional**     | Run cloudflared as a Docker container via Docker Compose.      |
| **Functional**     | Store configuration at `CLOUDFLARE_CONFIG_PATH` in repo.       |
| **Functional**     | Inject tunnel token from `CLOUDFLARE_TOKEN_SOURCE` at runtime. |
| **Functional**     | Source `CLOUDFLARE_IMAGE_TAG` from `ops/dependencies.md`.       |
| **Functional**     | Create `CLOUDFLARE_CONFIG_PATH` in repo before phase 1 setup.  |
| **Non-functional** | Pin `CLOUDFLARE_IMAGE_TAG` to a specific version.              |
| **Non-functional** | Prevent secrets from being written to disk on the VM.          |
| **Non-functional** | Tunnel tokens must never appear in `CLOUDFLARE_CONFIG_PATH`.   |
| **Non-functional** | Manual token injection must be in-session env vars only; no `.env` files on disk. |
| **Non-functional** | Keep host package inventory unchanged.                         |

## Architecture
- **Components:** Docker engine; Docker Compose; cloudflared container; CI secret store (phase 2 only).
- **Data flow (phase 1):** Operator injects token -> Docker Compose starts container -> cloudflared opens tunnel -> traffic proxies to app container.
- **Data flow (phase 2):** CI injects token -> Docker Compose starts container -> cloudflared opens tunnel -> traffic proxies to app container.
- **External dependencies:** Cloudflare tunnel service; Docker image registry.
- **Deployment model:** Phase 1 manual on the VM; phase 2 CI runs `docker compose up -d` with environment injection.
- **Diagram description:** A single VM running app containers and a cloudflared container, with a tunnel to Cloudflare edge and inbound traffic routed through the tunnel.

## Data Design
- **Entities:** `ops/cloudflared/config.yml` for non-secret settings; tunnel token provided at runtime.
- **Relationships:** cloudflared reads config from repo and token from environment.
- **Storage/retention:** Config in repo; phase 1 config is manually copied to the VM using `CONFIG_TRANSFER_METHOD`; secrets only in runtime env or CI secrets.
- **Verification:** Compare a checksum of `ops/cloudflared/config.yml` against the VM copy during phase 1.

## Security
- **Threats:** Token leakage; unpinned container drift; config tampering.
- **Mitigations:** CI secret storage (phase 2); in-session env injection only (phase 1); no tokens in config files; pinned image tags; repo review controls; config checksum verification.
- **Secrets:** Tunnel token injected as env var at runtime.

## Observability
- **Logging:** Container logs captured by Docker; log rotation per host policy.
- **Metrics:** Health status via container health check.
- **Alerts:** Not implemented; manual checks.

## Testing Strategy
- **Unit:** Validate config file schema and presence of required fields.
- **Integration:** Bring up compose stack and confirm tunnel connects from the VM.
- **E2E:** Verify external request reaches app through Cloudflare after the tunnel is live.

## Rollout Plan
- **Milestones:** Add config file; add compose service; manually inject token and deploy; enable CI SSH; move token to CI secrets.
- **Rollback:** Stop cloudflared service and revert compose changes; remove token from runtime env and CI secrets.

## Implementation Tasks
| **Task** | **Description** |
| --- | --- |
| Plan installation | Use this doc and `Design/1. package handling design.md` to confirm container-based install. |
| Manual setup on VM | Copy config to VM, verify checksum, inject token in-session only, and start the container. |
| Enable CI access | After public access exists, configure SSH and move token to CI secrets. |
| Record version | Capture `CLOUDFLARE_IMAGE_TAG` in the repo and ops notes. |

## Risks and Mitigations
- **Risk:** Cloudflare service or image change causes downtime. **Mitigation:** Pin image tags and monitor release notes.
- **Risk:** Token rotation not propagated. **Mitigation:** Re-deploy on secret update.
- **Risk:** Manual token injection is inconsistent. **Mitigation:** Document a single VM command path and remove token after handoff to CI.

## Open Questions
- **Question:** Confirm `CLOUDFLARE_PRODUCT` is Cloudflare Tunnel (cloudflared), not WARP or other services.
- **Question:** Preferred method for generating and rotating tunnel tokens?
